/*
 * generated by Xtext 2.22.0
 */
package symboleoide.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import symboleoide.services.SymboleoideGrammarAccess;
import symboleoide.symboleoide.Atom;
import symboleoide.symboleoide.CType;
import symboleoide.symboleoide.Contract;
import symboleoide.symboleoide.ContractSpec;
import symboleoide.symboleoide.DConcept;
import symboleoide.symboleoide.DeclarPair;
import symboleoide.symboleoide.DomainSpec;
import symboleoide.symboleoide.DomainType;
import symboleoide.symboleoide.EventProp;
import symboleoide.symboleoide.IntConst;
import symboleoide.symboleoide.Interval;
import symboleoide.symboleoide.Junc;
import symboleoide.symboleoide.Name;
import symboleoide.symboleoide.Neg;
import symboleoide.symboleoide.Obl;
import symboleoide.symboleoide.Pair;
import symboleoide.symboleoide.Point;
import symboleoide.symboleoide.PointConst;
import symboleoide.symboleoide.Pow;
import symboleoide.symboleoide.Prop;
import symboleoide.symboleoide.SitName;
import symboleoide.symboleoide.SitProp;
import symboleoide.symboleoide.SymboleoidePackage;
import symboleoide.symboleoide.TypeName;
import symboleoide.symboleoide.cEvent;
import symboleoide.symboleoide.cState;
import symboleoide.symboleoide.enumItem;
import symboleoide.symboleoide.oEvent;
import symboleoide.symboleoide.oState;
import symboleoide.symboleoide.pEvent;
import symboleoide.symboleoide.pState;

@SuppressWarnings("all")
public class SymboleoideSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SymboleoideGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SymboleoidePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SymboleoidePackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case SymboleoidePackage.CTYPE:
				sequence_CType(context, (CType) semanticObject); 
				return; 
			case SymboleoidePackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case SymboleoidePackage.CONTRACT_SPEC:
				sequence_ContractSpec(context, (ContractSpec) semanticObject); 
				return; 
			case SymboleoidePackage.DCONCEPT:
				sequence_DConcept(context, (DConcept) semanticObject); 
				return; 
			case SymboleoidePackage.DECLAR_PAIR:
				if (rule == grammarAccess.getParamRule()
						|| rule == grammarAccess.getDeclarPairRule()) {
					sequence_DeclarPair(context, (DeclarPair) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarRule()) {
					sequence_Declar_DeclarPair(context, (DeclarPair) semanticObject); 
					return; 
				}
				else break;
			case SymboleoidePackage.DOMAIN_SPEC:
				sequence_DomainSpec(context, (DomainSpec) semanticObject); 
				return; 
			case SymboleoidePackage.DOMAIN_TYPE:
				sequence_DomainType(context, (DomainType) semanticObject); 
				return; 
			case SymboleoidePackage.EVENT_PROP:
				sequence_EventProp(context, (EventProp) semanticObject); 
				return; 
			case SymboleoidePackage.INT_CONST:
				sequence_IntConst(context, (IntConst) semanticObject); 
				return; 
			case SymboleoidePackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SymboleoidePackage.JUNC:
				sequence_Junc(context, (Junc) semanticObject); 
				return; 
			case SymboleoidePackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case SymboleoidePackage.NEG:
				sequence_Neg(context, (Neg) semanticObject); 
				return; 
			case SymboleoidePackage.OBL:
				sequence_Obl(context, (Obl) semanticObject); 
				return; 
			case SymboleoidePackage.PAIR:
				sequence_Pair(context, (Pair) semanticObject); 
				return; 
			case SymboleoidePackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case SymboleoidePackage.POINT_CONST:
				sequence_PointConst(context, (PointConst) semanticObject); 
				return; 
			case SymboleoidePackage.POW:
				sequence_Pow(context, (Pow) semanticObject); 
				return; 
			case SymboleoidePackage.PROP:
				sequence_Prop(context, (Prop) semanticObject); 
				return; 
			case SymboleoidePackage.SIT_NAME:
				sequence_SitName(context, (SitName) semanticObject); 
				return; 
			case SymboleoidePackage.SIT_PROP:
				sequence_SitProp(context, (SitProp) semanticObject); 
				return; 
			case SymboleoidePackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case SymboleoidePackage.CEVENT:
				sequence_cEvent(context, (cEvent) semanticObject); 
				return; 
			case SymboleoidePackage.CSTATE:
				sequence_cState(context, (cState) semanticObject); 
				return; 
			case SymboleoidePackage.ENUM_ITEM:
				sequence_enumItem(context, (enumItem) semanticObject); 
				return; 
			case SymboleoidePackage.OEVENT:
				sequence_oEvent(context, (oEvent) semanticObject); 
				return; 
			case SymboleoidePackage.OSTATE:
				sequence_oState(context, (oState) semanticObject); 
				return; 
			case SymboleoidePackage.PEVENT:
				sequence_pEvent(context, (pEvent) semanticObject); 
				return; 
			case SymboleoidePackage.PSTATE:
				sequence_pState(context, (pState) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Atom returns Atom
	 *
	 * Constraint:
	 *     (
	 *         eventPropositions+=EventProp | 
	 *         situationPropositions+=SitProp | 
	 *         (shortHandNames+=Name names+=Name* names+=Name points+=Point* intervals+=Interval*) | 
	 *         (points+=Point intervals+=Interval) | 
	 *         propositions+=Prop | 
	 *         (varName+=Name setExps+=SetExp metaconstraints+=MetaConst) | 
	 *         (varName+=Name setExps+=SetExp metaconstraints+=MetaConst)
	 *     )?
	 */
	protected void sequence_Atom(ISerializationContext context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CType returns CType
	 *
	 * Constraint:
	 *     {CType}
	 */
	protected void sequence_CType(ISerializationContext context, CType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractSpec returns ContractSpec
	 *
	 * Constraint:
	 *     (domainSpecs+=DomainSpec contracts+=Contract)
	 */
	protected void sequence_ContractSpec(ISerializationContext context, ContractSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameters+=Param+ 
	 *         parameters+=Param 
	 *         declarations+=Declar* 
	 *         propositions+=Prop* 
	 *         propositions+=Prop* 
	 *         obligations+=Obl+ 
	 *         obligations+=Obl* 
	 *         powers+=Pow* 
	 *         propositions+=Prop*
	 *     )
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DConcept returns DConcept
	 *
	 * Constraint:
	 *     ((name=ID conceptTypes+=CType attributes+=Att* attributes+=Att?) | (name=ID enumerationItems+=enumItem* enumerationItems+=enumItem))
	 */
	protected void sequence_DConcept(ISerializationContext context, DConcept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Param returns DeclarPair
	 *     DeclarPair returns DeclarPair
	 *
	 * Constraint:
	 *     (name=ID typeNames+=TypeName)
	 */
	protected void sequence_DeclarPair(ISerializationContext context, DeclarPair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declar returns DeclarPair
	 *
	 * Constraint:
	 *     (name=ID typeNames+=TypeName (names+=Name names+=Name)* names+=Name names+=Name)
	 */
	protected void sequence_Declar_DeclarPair(ISerializationContext context, DeclarPair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainSpec returns DomainSpec
	 *
	 * Constraint:
	 *     (name=ID dConcepts+=DConcept+ ctypes+=CType?)
	 */
	protected void sequence_DomainSpec(ISerializationContext context, DomainSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CType returns DomainType
	 *     DomainType returns DomainType
	 *
	 * Constraint:
	 *     dtypes+=[DConcept|ID]
	 */
	protected void sequence_DomainType(ISerializationContext context, DomainType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventProp returns EventProp
	 *
	 * Constraint:
	 *     ((eventName=[Declar|ID] points+=Point) | (oEventName=oEvent points+=Point) | (cEventName=cEvent points+=Point) | (pEventName=pEvent points+=Point))
	 */
	protected void sequence_EventProp(ISerializationContext context, EventProp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntConst returns IntConst
	 *
	 * Constraint:
	 *     Type=INT
	 */
	protected void sequence_IntConst(ISerializationContext context, IntConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.INT_CONST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.INT_CONST__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntConstAccess().getTypeINTTerminalRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (
	 *         situationName=SitName | 
	 *         (points+=Point points+=Point) | 
	 *         (situationNames+=SitName tempOps+=TempOp intConsts+=IntConst units+=Unit) | 
	 *         (intConsts+=IntConst units+=Unit tempOps+=TempOp situationNames+=SitName)
	 *     )?
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Junc returns Junc
	 *
	 * Constraint:
	 *     (negativeAtoms+=Neg negativeAtoms+=Neg*)
	 */
	protected void sequence_Junc(ISerializationContext context, Junc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Neg returns Neg
	 *
	 * Constraint:
	 *     atomicExpressions+=Atom
	 */
	protected void sequence_Neg(ISerializationContext context, Neg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Obl returns Obl
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         trigger=Prop? 
	 *         roles+=Name 
	 *         roles+=Name 
	 *         antecedent=Prop 
	 *         consequent=Prop
	 *     )
	 */
	protected void sequence_Obl(ISerializationContext context, Obl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Att returns Pair
	 *     Pair returns Pair
	 *
	 * Constraint:
	 *     (name=ID types+=CType)
	 */
	protected void sequence_Pair(ISerializationContext context, Pair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PointConst returns PointConst
	 *
	 * Constraint:
	 *     Type=INT
	 */
	protected void sequence_PointConst(ISerializationContext context, PointConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.POINT_CONST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.POINT_CONST__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointConstAccess().getTypeINTTerminalRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     (
	 *         eventNames+=SitName | 
	 *         pointConsts+=PointConst | 
	 *         (pointConsts+=PointConst units+=Unit tempOps+=TempOp eventNames+=SitName) | 
	 *         (eventNames+=SitName tempOps+=TempOp pointConsts+=PointConst units+=Unit)
	 *     )?
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pow returns Pow
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         trigger=Prop? 
	 *         roles+=Name 
	 *         roles+=Name 
	 *         antecedents+=Prop 
	 *         consequents+=Prop
	 *     )
	 */
	protected void sequence_Pow(ISerializationContext context, Pow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Prop returns Prop
	 *
	 * Constraint:
	 *     (junctions+=Junc junctions+=Junc*)
	 */
	protected void sequence_Prop(ISerializationContext context, Prop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SitName returns SitName
	 *
	 * Constraint:
	 *     (
	 *         SitName+=Name | 
	 *         oStates+=oState | 
	 *         pStates+=pState | 
	 *         cStates+=cState | 
	 *         oEvents+=oEvent | 
	 *         cEvents+=cEvent | 
	 *         pEvents+=pEvent
	 *     )
	 */
	protected void sequence_SitName(ISerializationContext context, SitName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SitProp returns SitProp
	 *
	 * Constraint:
	 *     (
	 *         (situationName=[Name|ID] intervals+=Interval) | 
	 *         (oSituationName=oState intervals+=Interval) | 
	 *         (cSituationName=cState intervals+=Interval) | 
	 *         (pSituationName=pState intervals+=Interval)
	 *     )
	 */
	protected void sequence_SitProp(ISerializationContext context, SitProp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeName returns TypeName
	 *
	 * Constraint:
	 *     name=ID?
	 */
	protected void sequence_TypeName(ISerializationContext context, TypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cEvent returns cEvent
	 *
	 * Constraint:
	 *     (contrEvent=ContrEvent contrName=[Contract|ID])
	 */
	protected void sequence_cEvent(ISerializationContext context, cEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.CEVENT__CONTR_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.CEVENT__CONTR_EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.CEVENT__CONTR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.CEVENT__CONTR_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCEventAccess().getContrEventContrEventParserRuleCall_0_0(), semanticObject.getContrEvent());
		feeder.accept(grammarAccess.getCEventAccess().getContrNameContractIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SymboleoidePackage.Literals.CEVENT__CONTR_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     cState returns cState
	 *
	 * Constraint:
	 *     (contrState=ContrState contractName=[Contract|ID])
	 */
	protected void sequence_cState(ISerializationContext context, cState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.CSTATE__CONTR_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.CSTATE__CONTR_STATE));
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.CSTATE__CONTRACT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.CSTATE__CONTRACT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCStateAccess().getContrStateContrStateParserRuleCall_0_0(), semanticObject.getContrState());
		feeder.accept(grammarAccess.getCStateAccess().getContractNameContractIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SymboleoidePackage.Literals.CSTATE__CONTRACT_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumItem returns enumItem
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_enumItem(ISerializationContext context, enumItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.ENUM_ITEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.ENUM_ITEM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumItemAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     oEvent returns oEvent
	 *
	 * Constraint:
	 *     (oblEvent=OblEvent oblName=[Obl|ID])
	 */
	protected void sequence_oEvent(ISerializationContext context, oEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.OEVENT__OBL_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.OEVENT__OBL_EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.OEVENT__OBL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.OEVENT__OBL_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOEventAccess().getOblEventOblEventParserRuleCall_0_0(), semanticObject.getOblEvent());
		feeder.accept(grammarAccess.getOEventAccess().getOblNameOblIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SymboleoidePackage.Literals.OEVENT__OBL_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     oState returns oState
	 *
	 * Constraint:
	 *     (oblState=OblState oblName=[Obl|ID])
	 */
	protected void sequence_oState(ISerializationContext context, oState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.OSTATE__OBL_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.OSTATE__OBL_STATE));
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.OSTATE__OBL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.OSTATE__OBL_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOStateAccess().getOblStateOblStateParserRuleCall_0_0(), semanticObject.getOblState());
		feeder.accept(grammarAccess.getOStateAccess().getOblNameOblIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SymboleoidePackage.Literals.OSTATE__OBL_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     pEvent returns pEvent
	 *
	 * Constraint:
	 *     (powEvent=PowEvent powName=[Pow|ID])
	 */
	protected void sequence_pEvent(ISerializationContext context, pEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.PEVENT__POW_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.PEVENT__POW_EVENT));
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.PEVENT__POW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.PEVENT__POW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPEventAccess().getPowEventPowEventParserRuleCall_0_0(), semanticObject.getPowEvent());
		feeder.accept(grammarAccess.getPEventAccess().getPowNamePowIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SymboleoidePackage.Literals.PEVENT__POW_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     pState returns pState
	 *
	 * Constraint:
	 *     (powState=PowState powName=[Pow|ID])
	 */
	protected void sequence_pState(ISerializationContext context, pState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.PSTATE__POW_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.PSTATE__POW_STATE));
			if (transientValues.isValueTransient(semanticObject, SymboleoidePackage.Literals.PSTATE__POW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SymboleoidePackage.Literals.PSTATE__POW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPStateAccess().getPowStatePowStateParserRuleCall_0_0(), semanticObject.getPowState());
		feeder.accept(grammarAccess.getPStateAccess().getPowNamePowIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SymboleoidePackage.Literals.PSTATE__POW_NAME, false));
		feeder.finish();
	}
	
	
}
